<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=description content="主进程 每一个Qt程序被创建时，默认有一个主线程，启动无限循环，并监控Signal。 我们看到的打开窗口 、点按钮、关闭窗口就是主线程的功劳。 from PySide2.QtWidgets import QApplication, QMainWindow app = QApplication(sys.argv) #主线程Application window = MainWindow() # 窗口 window.show() sys.exit(app.exec_()) 但"><meta name=KEYWORDS content="[多线程 PyQt PySide2]"><meta name=robots content="index,follow"><meta name=googlebot content="index,follow"><base href=http://52etf.net/blog/2020-06-01-pyqt%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B8%89%E5%A4%9A%E7%BA%BF%E7%A8%8B/><meta property="og:title" content="PyQt开发笔记（三）多线程 | 我爱ETF"><meta name=twitter:title content="PyQt开发笔记（三）多线程 | 我爱ETF"><meta itemprop=name content="PyQt开发笔记（三）多线程 | 我爱ETF"><meta name=application-name content="PyQt开发笔记（三）多线程 | 我爱ETF"><meta property="og:site_name" content><meta name=description content="主进程 每一个Qt程序被创建时，默认有一个主线程，启动无限循环，并监控Signal。 我们看到的打开窗口 、点按钮、关闭窗口就是主线程的功劳。 from PySide2.QtWidgets import QApplication, QMainWindow app = QApplication(sys.argv) #主线程Application window = MainWindow() # 窗口 window.show() sys.exit(app.exec_()) 但"><meta itemprop=description content="主进程 每一个Qt程序被创建时，默认有一个主线程，启动无限循环，并监控Signal。 我们看到的打开窗口 、点按钮、关闭窗口就是主线程的功劳。 from PySide2.QtWidgets import QApplication, QMainWindow app = QApplication(sys.argv) #主线程Application window = MainWindow() # 窗口 window.show() sys.exit(app.exec_()) 但"><meta property="og:description" content="主进程 每一个Qt程序被创建时，默认有一个主线程，启动无限循环，并监控Signal。 我们看到的打开窗口 、点按钮、关闭窗口就是主线程的功劳。 from PySide2.QtWidgets import QApplication, QMainWindow app = QApplication(sys.argv) #主线程Application window = MainWindow() # 窗口 window.show() sys.exit(app.exec_()) 但"><meta name=twitter:description content="主进程 每一个Qt程序被创建时，默认有一个主线程，启动无限循环，并监控Signal。 我们看到的打开窗口 、点按钮、关闭窗口就是主线程的功劳。 from PySide2.QtWidgets import QApplication, QMainWindow app = QApplication(sys.argv) #主线程Application window = MainWindow() # 窗口 window.show() sys.exit(app.exec_()) 但"><meta name=url content="http://52etf.net/blog/2020-06-01-pyqt%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B8%89%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><meta name=twitter:url content="http://52etf.net/blog/2020-06-01-pyqt%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B8%89%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><meta property="og:url" content="http://52etf.net/blog/2020-06-01-pyqt%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B8%89%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><link rel=canonical href=http://52etf.net/blog/2020-06-01-pyqt%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B8%89%E5%A4%9A%E7%BA%BF%E7%A8%8B/ itemprop=url><link id=favicon rel=icon type=image/x-icon href=/img/favicon.ico><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/github-markdown.min.css><link rel=stylesheet href=/css/addon.css><meta name=referrer content="no-referrer"><title>我爱ETF</title></head><body><header id=header><nav class=topnav id=myTopNav><ol><li><a href=/>首页</a></li><li><a href=/dash/>市场仪表盘</a></li><li><a href=/books/>投资书单</a></li><li><a href=/funds/>精选基金</a></li><li><a href=/tools/>量化工具</a></li><li><a href=/tags/>词云</a></li><li><a href=/blog/>博客</a></li><li><a href=/about/>关于</a></li></ol></nav></header><main id=main><article class=markdown-body><h1>PyQt开发笔记（三）多线程
<span class=article_date>Jun 1, 2020</span></h1><h2 id=主进程>主进程</h2><p>每一个Qt程序被创建时，默认有一个主线程，启动无限循环，并监控Signal。</p><p>我们看到的打开窗口 、点按钮、关闭窗口就是主线程的功劳。</p><pre><code>from PySide2.QtWidgets import QApplication, QMainWindow
app = QApplication(sys.argv) #主线程Application
window = MainWindow() # 窗口
window.show()
sys.exit(app.exec_())
</code></pre><p>但由于主线程是唯一的，任何阻挡主线程循环事件的函数都会“阻塞”主线程，导致看起来界面没有响应，非常蓝瘦。比如，</p><pre><code>from PySide2.QtWidgets import QApplication, QMainWindow
app = QApplication(sys.argv)
window = MainWindow()
import time
time.sleep(10) # 这里插入一个等待，界面会10s后才打开
window.show()
sys.exit(app.exec_())
</code></pre><h2 id=多线程>多线程</h2><p>为了解决这个问题，Qt中有多线程组件，用于处理耗时操作，效果就是不阻塞QApplication主界面。</p><p><strong>Qt的任何Widget都是QThread友好的</strong>，也就是说任何窗口也可以作为Thread被创建。创建另一个大型复杂窗口同样可以不影响主Application。</p><pre><code>from PySide2.QtCore import QThread
class MyLongTask(QThread):
    def __init__(self):
        super(MyLongClass).__init__()
    
    def run(self):
        import time
        time.sleep(10) #模拟一个耗时操作

app = QApplication(sys.argv)
window = MainWindow()
myLongTask = MyLongTask() #初始化
myLongTask.start() #运行后处于子线程
window.show() # 窗口立即显示
sys.exit(app.exec_())
</code></pre><h2 id=可控数量进程>可控数量进程</h2><p>线程虽然可以不阻塞主Application，但并发带来一个弊端就是运行顺序不再受控制。</p><p>如果既要不阻塞主进程，又要顺序执行，可以使用QThreadPool和QRunnable，前者可以控制Thread的运行数量，设置为1即可按照先进先运行顺序运行。也可以将子线程分类，不阻塞的分到不同的Pool中，依赖顺序的的放到一个Pool里面。</p><pre><code>from PySide2.QtCore import QRunnable, QThreadPool
class MyLongTask(QRunnable):
    def __init__(self, id):
        super(MyLongClass).__init__()
        self.id = id
    
    def run(self):
        import time
        time.sleep(10) #模拟一个耗时操作
        print(self.id) #打印id

app = QApplication(sys.argv)
window = MainWindow()
myPool = QThreadPool()
myPool.setMaxThreadCount(1)
for i in range(10):
  myLongTask = MyLongTask(i) #初始化10个进程
  myPool.start(myLongTask) #运行后处于子线程，顺序打印id(0-9)
window.show() # 窗口立即显示，并没有被10个进程阻塞
sys.exit(app.exec_())
</code></pre><h2 id=线程通信>线程通信</h2><p>概念很大，但比较容易理解。</p><p>GUI程序的核心在于交互，界面上的元素互动交互，例如鼠标移动，打飞机游戏跟着滚动，其他物品躲避。</p><p>其次是用户和界面直接的交互，比如输入一些信息、点击按钮。</p><p>这些交互被封装到QApplication主进程，其实也是有滞后的，不过循环非常快，用户感知不到明显滞后和卡顿。</p><p>当我们用了线程之后，由于是耗时操作，开始和结束时的互动就存在明显滞后。</p><p>总之，为了解决线程通信Qt的方案是捕捉信号后触发，就是Signal和Slot的概念，可以用在主线程（界面）和子线程之间，也可以用在所有线程之间。</p><p>学Qt必须要掌握的一个基本概念，理解了Signal和Slot就基本理解了Qt程序设计的基本思路。</p><p>Signal的本质是产生信号，信号的作用是继续下一步的动作（Slot），可以使任何动作，这样就将元素连接了起来。</p><p>绑定信号和Slot，用的是Signal.connect(slot_function)，普通的函数不是Slot函数，只有内置的Slot可以访问（例如点击、关闭、内容改变等等）。</p><p>但PyQt中提供了强大的Slot装饰器，可以将任何函数和类包装秤Slot。</p><pre><code>@Slot()
def slot_me():
  print('i am ordinary slotted function')
</code></pre><h2 id=通用的线程对象>通用的线程对象</h2><p>多线程是如此的常见，而信号和槽位无处不在，我实在想不出Qt为什么不直接包装一个通用的对象。</p><p>既然没有，我们设计一个。底稿是，</p><pre><code>class WorkerSignal(QObject):
    #一个进程结束通常有三个返回值，是否成功、报错、结果
    #注意Signal只能以QObject创建
    done = Signal()
    error = Signal(tuple)
    result = Signal(QObject)
    
class Worker(QRunnable):
    def __init__(self, fn, *args, **kwargs):
    #我们的Worker接受任何操作
        self.fn = fn
        self.args = args
        self.kwargs = kwargs
        self.signals = WorkerSignal()
        
    def run(self):
        try:
            result = self.fn(*self.args, **self.kwargs)
         except:
            #捕捉到错误
            traceback.print_exc()
            exctype, value = sys.exc_info()[:2]
            self.signals.error.emit((exctype, value, traceback.format_exc()))
        else:
            #如果没有处罚exception，则发射结果
            self.signals.result.emit(result)
        finally:
            #无论如何告诉别人自己结束了，附带发射一波
            self.signals.done.emit()
</code></pre><p>通过以上的Worker和Signal设计，我们就有了一个通用的Worker可以接受任何苦力劳动，并且劳动时及时告诉老板干的怎么样。</p><p>在主线程或者其他线程中，捕捉到signal后，可以绑定signal触发下一个Slot，这个世界就被连接了起来，产生无限的可能。</p><h2 id=尾声>尾声</h2><p>通过理解线程的概念，可以知道Qt世界是怎么连接起来的。就像Linux设计这算，Do it right, Do it once一样，虽然功能很小，但一个PIPE |连接符，把整个Unix的文件访问输入输出全部连接了起来。 Qt的Signal和Slot也是类似的设计，简单有效。</p></article><article id=article_tags><a class=item__tag href=/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B>#多线程</a>
<a class=item__tag href=/tags/pyqt>#PyQt</a>
<a class=item__tag href=/tags/pyside2>#PySide2</a></article><div style=text-align:center><img src=/img/weixin_banner.png width=40%;></div><article id=article_nav><a href=http://52etf.net/blog/2020-06-02-pyqt%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%BA%94%E7%99%BB%E5%BD%95%E7%AA%97%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0-copy/>新一篇：PyQt开发笔记（五）登录窗口</a>
<a href=http://52etf.net/blog/2020-06-01-pyqt%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E5%9B%9B%E9%80%9A%E7%94%A8worker/>老一篇：PyQt开发笔记（四）通用的Worker</a></article><article class=single><h3>推荐阅读:</h3><ol><li><a href=/blog/2020-06-01-pyqt%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E5%9B%9B%E9%80%9A%E7%94%A8worker/>PyQt开发笔记（四）通用的Worker</a></li><li><a href=/blog/2020-05-31-pyqt%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%BA%8C-/>PyQt开发笔记（二）</a></li><li><a href=/blog/2020-05-15-pyqt%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B8%80/>PyQt开发笔记（一）</a></li></ol></article><script src=//unpkg.com/valine/dist/Valine.min.js></script><div id=vcomments></div><script>new Valine({el:'#vcomments',appId:'oc9Q6EXPyOTsTB1u3TF69zx5-gzGzoHsz',appKey:'K9hd59av2lhDkYwXfBGAHFdB',placeholder:'请您在评论时遵守国家法律法规，谢谢',visitor:false,})</script></main><footer id=footer><ul><li><a href=http://52etf.net>版权&copy;52etf.net</a></li><li><a href=https://creativecommons.org/licenses/by-sa/4.0/deed.zh>协议CC BY-SA 4.0</a></li><li><a href=http://www.beian.miit.gov.cn>豫ICP备20016066号</a></li></ul></footer></body></html>