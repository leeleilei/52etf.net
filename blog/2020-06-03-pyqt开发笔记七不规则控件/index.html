<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=description content="和打印日志一样，进度条通常是为了稍微管理下用户等待预期，同时直白的告诉他们我还没死，等会儿再C+A+D杀死我。 我们理解了信号和UI交互的逻辑，可以很容易理解进度条的实现逻辑， 一个label用来显示进度"><meta name=KEYWORDS content="[PyQt PySide2 Python]"><meta name=robots content="index,follow"><meta name=googlebot content="index,follow"><base href=http://52etf.net/blog/2020-06-03-pyqt%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B8%83%E4%B8%8D%E8%A7%84%E5%88%99%E6%8E%A7%E4%BB%B6/><meta property="og:title" content="PyQt开发笔记（七）不规则进度条 | 我爱ETF"><meta name=twitter:title content="PyQt开发笔记（七）不规则进度条 | 我爱ETF"><meta itemprop=name content="PyQt开发笔记（七）不规则进度条 | 我爱ETF"><meta name=application-name content="PyQt开发笔记（七）不规则进度条 | 我爱ETF"><meta property="og:site_name" content><meta name=description content="和打印日志一样，进度条通常是为了稍微管理下用户等待预期，同时直白的告诉他们我还没死，等会儿再C+A+D杀死我。 我们理解了信号和UI交互的逻辑，可以很容易理解进度条的实现逻辑， 一个label用来显示进度"><meta itemprop=description content="和打印日志一样，进度条通常是为了稍微管理下用户等待预期，同时直白的告诉他们我还没死，等会儿再C+A+D杀死我。 我们理解了信号和UI交互的逻辑，可以很容易理解进度条的实现逻辑， 一个label用来显示进度"><meta property="og:description" content="和打印日志一样，进度条通常是为了稍微管理下用户等待预期，同时直白的告诉他们我还没死，等会儿再C+A+D杀死我。 我们理解了信号和UI交互的逻辑，可以很容易理解进度条的实现逻辑， 一个label用来显示进度"><meta name=twitter:description content="和打印日志一样，进度条通常是为了稍微管理下用户等待预期，同时直白的告诉他们我还没死，等会儿再C+A+D杀死我。 我们理解了信号和UI交互的逻辑，可以很容易理解进度条的实现逻辑， 一个label用来显示进度"><meta name=url content="http://52etf.net/blog/2020-06-03-pyqt%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B8%83%E4%B8%8D%E8%A7%84%E5%88%99%E6%8E%A7%E4%BB%B6/"><meta name=twitter:url content="http://52etf.net/blog/2020-06-03-pyqt%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B8%83%E4%B8%8D%E8%A7%84%E5%88%99%E6%8E%A7%E4%BB%B6/"><meta property="og:url" content="http://52etf.net/blog/2020-06-03-pyqt%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B8%83%E4%B8%8D%E8%A7%84%E5%88%99%E6%8E%A7%E4%BB%B6/"><link rel=canonical href=http://52etf.net/blog/2020-06-03-pyqt%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B8%83%E4%B8%8D%E8%A7%84%E5%88%99%E6%8E%A7%E4%BB%B6/ itemprop=url><link id=favicon rel=icon type=image/x-icon href=/img/favicon.ico><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/github-markdown.min.css><link rel=stylesheet href=/css/addon.css><meta name=referrer content="no-referrer"><title>我爱ETF</title></head><body><header id=header><nav class=topnav id=myTopNav><ol><li><a href=/>首页</a></li><li><a href=/dash/>市场仪表盘</a></li><li><a href=/books/>书单</a></li><li><a href=/tags/%E7%B2%BE%E9%80%89%E5%9F%BA%E9%87%91/>精选基金</a></li><li><a href=/tools/>量化工具</a></li><li><a href=/tags/>词云</a></li><li><a href=/blog/>博客</a></li><li><a href=/about/>关于</a></li></ol></nav></header><main id=main><article class=markdown-body><h1>PyQt开发笔记（七）不规则进度条</h1><span class=article_date>Jun 26, 2020</span><p>和打印日志一样，进度条通常是为了稍微管理下用户等待预期，同时直白的告诉他们我还没死，等会儿再C+A+D杀死我。</p><p>我们理解了信号和UI交互的逻辑，可以很容易理解进度条的实现逻辑，</p><ol><li>一个label用来显示进度</li><li>一个信号</li><li>一个QThread跑后台应用，挂载一个信号，每当应用取得一个进展就emit一次</li><li>信号connect到slot</li><li>slot设置label的字符或者向前滚动</li></ol><p>基于这个原理，我们可以设计一个乌龟爬的进度条，:D</p><h2 id=用qt-designer设计ui>用Qt Designer设计Ui</h2><p><img src=https://52etf.oss-cn-beijing.aliyuncs.com/picgo/20200604113118.png alt=20200604113118></p><p>用LineEdit来填充“#”字符，同时放上一个button来向前滚动，右侧是一个数字label。</p><p>button组件会被设置显示为gif，类似不规则UI组件。</p><h2 id=一个信号类>一个信号类</h2><p>一个接收进度的信号，同时绑定到“小乌龟”button身上。用我们上一张设计的通用Signal。</p><pre><code>class WorkerSignal(QObject):
    #一个进程结束通常有三个返回值，是否成功、报错、结果
    #注意Signal只能以QObject创建
    prog = Signal(int)
    done = Signal()
    error = Signal(tuple)
    result = Signal(QObject)

#和slot的绑定在主UI那里写
</code></pre><h2 id=一个qthread来模拟后台应用>一个QThread来模拟后台应用</h2><p>我们用time.sleep来模拟计算机的中断等待和其他任务处理类，总之就是耗时等待。并将这个耗时等待放到前一张我们写的通用Worker类中去跑任务。</p><pre><code>class WorkerSignal(QObject):
    #一个进程结束通常有三个返回值，是否成功、报错、结果
    #注意Signal只能以QObject创建
    prog = Signal(int)
    done = Signal()
    error = Signal(tuple)
    result = Signal(QObject)
    
class Worker(QRunnable):
    def __init__(self, fn, *args, **kwargs):
    #我们的Worker接受任何操作
        self.fn = fn
        self.args = args
        self.kwargs = kwargs
        
    def run(self):
        try:
            result = self.fn(*self.args, **self.kwargs)
         except:
            #捕捉到错误
            traceback.print_exc()
            exctype, value = sys.exc_info()[:2]
            self.signals.error.emit((exctype, value, traceback.format_exc()))
        else:
            #如果没有处罚exception，则发射结果
            self.signals.result.emit(result)
        finally:
            #无论如何告诉别人自己结束了，附带发射一波
            self.signals.done.emit()

signalConn = WorkerSignal()
def long_run(seconds, signalConn): #为了报告进度，我们要传入一个Signal对象
    import time
    count=0
    for i in range(seconds):
        time.sleep(i)
        count+=1
        signalConn.prog.emit(count)

lrWorker = Worker(long_run, 10, signalConn) #创建一个Worker实例

pool = QPool() #初始化Pool
pool.setMaximumThreadCount(1) #一次一个进程
pool.start(lrWorker) #启动
</code></pre><h2 id=绑定信号到label显示内容>绑定信号到label显示内容</h2><pre><code>signalConn.connect(turtle_move)

@Slot()
def turtal_move():
    pass

</code></pre><h3 id=显示字符>显示字符</h3><p>def turtle_move(value):
text = self.lineEdit_bar.text()
self.lineEdit_bar.setText(text+&rsquo;#')</p><pre><code>
### 控制乌龟的位置（label长度的百分比位置）
</code></pre><pre><code>#
pct = value/100
x, y = self.lineEdit_bar.pos()
w = self.pushButton_gif.width()
h = self.pushButton_gif.height()
x = x + self.lineEdit_bar.width() * pct #重新计算坐标
self.pushButton_gif.repaint(x, y) # 重新绘制位置
</code></pre><pre><code>
## 尾声
通过理解进度条的原理，我们进一步巩固Qt的信号和Slot涵义，可以更自由的定制一些任务。

</code></pre></article><article id=article_tags><a class=item__tag href=/tags/pyqt>#PyQt</a>
<a class=item__tag href=/tags/pyside2>#PySide2</a>
<a class=item__tag href=/tags/python>#Python</a></article><div style=text-align:center><img src=/img/weixin_banner.png width=40%;></div><article id=article_nav><a href=http://52etf.net/blog/2585390929/>新一篇：typing — Support for type hints — Python 3.7.2 documentation</a>
<a href=http://52etf.net/blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>老一篇：Python设计模式</a></article><article class=single><h3>推荐阅读:</h3><ol><li><a href=/blog/2020-06-03-pyqt%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E5%85%AD%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0%E7%AA%97%E5%8F%A3/>PyQt开发笔记（六）日志打印窗口</a></li><li><a href=/blog/2020-06-02-pyqt%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%BA%94%E7%99%BB%E5%BD%95%E7%AA%97%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0-copy/>PyQt开发笔记（五）登录窗口</a></li><li><a href=/blog/2020-06-01-pyqt%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B8%89%E5%A4%9A%E7%BA%BF%E7%A8%8B/>PyQt开发笔记（三）多线程</a></li><li><a href=/blog/2020-06-01-pyqt%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E5%9B%9B%E9%80%9A%E7%94%A8worker/>PyQt开发笔记（四）通用的Worker</a></li><li><a href=/blog/2020-05-31-pyqt%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%BA%8C-/>PyQt开发笔记（二）</a></li></ol></article><script src=//unpkg.com/valine/dist/Valine.min.js></script><div id=vcomments></div><script>new Valine({el:'#vcomments',appId:'oc9Q6EXPyOTsTB1u3TF69zx5-gzGzoHsz',appKey:'K9hd59av2lhDkYwXfBGAHFdB',placeholder:'请您在评论时遵守国家法律法规，谢谢',visitor:false,})</script></main><footer id=footer><ul><li><a href=http://52etf.net>版权&copy;52etf.net</a></li><li><a href=https://creativecommons.org/licenses/by-sa/4.0/deed.zh>协议CC BY-SA 4.0</a></li><li><a href=http://www.beian.miit.gov.cn>豫ICP备20016066号</a></li></ul></footer></body></html>