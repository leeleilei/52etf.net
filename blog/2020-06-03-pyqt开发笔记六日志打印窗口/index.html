<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><link id=favicon rel=icon type=image/x-icon href=/img/favicon.ico><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/github-markdown.min.css><link rel=stylesheet href=/css/addon.css><meta name=referrer content="no-referrer"><script src=https://unpkg.com/zooming/build/zooming.min.js></script><script>document.addEventListener('DOMContentLoaded',function(){new Zooming({scaleExtra:0.6,}).listen('.img-zoomable')})</script><style>@font-face{font-family:notosanssc;src:url(/css/NotoSansSC-Thin.otf)}@font-face{font-family:roboto;src:url(/css/Roboto-Regular.ttf)}*{font-family:roboto,notosanssc!important}</style><title>我爱ETF</title></head><body><header id=header><nav class=topnav id=myTopNav><ol><li><a href=/>首页</a></li><li><a href=/dash/>市场仪表盘</a></li><li><a href=/books/>投资书单</a></li><li><a href=/funds/>精选基金</a></li><li><a href=/tools/>量化工具</a></li><li><a href=/tags/>词云</a></li><li><a href=/blog/>博客</a></li><li><a href=/about/>关于</a></li></ol></nav></header><main id=main><article id=markdown-body><h1>PyQt开发笔记（六）日志打印窗口</h1><h3>Wednesday, Jun 3, 2020</h3><p><p>通常习惯是用<code>Python logging</code>模块打印到日志文件中，但在GUI程序中，如果能实施调整日志等级，并打印到一个Text空间上，功能将会非常精彩。</p><p>很显然，要用到前几章谈到的QThread，Signal和Slot。另外需要自定义logger的emit函数和GUI空间关联。</p><p>打印日志时显然有耗时操作，QThread用来负担后台运行。</p><p>运行时的logger输出emit到Signal，然后connect到Text空间的append。</p><p>Logger本身可以视情况单独开QThread或者不开，因为不占用太多CPU时间。</p><h2 id=理解logger对象>理解Logger对象</h2><h3 id=root>root</h3><p>Python的logging模块设计的非常简洁高效，而且是QThread友好的。</p><p>logging模块有且只存在一个root模块，</p><pre><code>root = logging.getLogger()
anychild = logging.getLogger('chile')
</code></pre><p>获取之后root对象跟其他Logger对象是相同的类。 不同的是默认级别，默认的Handler不同。</p><h3 id=root和child的关系>root和child的关系</h3><p>子Logger和root Logger的关系是PIPE关系，所有的子Logger数据都会最终流经root Logger，被format，被level过滤，被handler处理一次。</p><p>直观的例子是，默认root没有handler，在添加一个StreamHandler后，如果其他子Logger打印日志时会被打印两次。</p><h3 id=共享logger>共享logger</h3><p>如果想共享Logger，打印日志到同一个文件，可以直接getLogger(&lsquo;loggername&rsquo;)就能访问到。通常，在utils.py文件中初始化一个公共logger。</p><h3 id=重定向logger输出>重定向logger输出</h3><p>我们知道logger有很多的Handlers，其本质是继承了emit方法。</p><p>我们想让logger打印到<strong>信号</strong>中，就重写这个函数</p><pre><code>class LogEmittedConn(QtCore.QObject):
    signal = QtCore.Signal(str)


class GuiLoggerHandler(logging.Handler):

    def __init__(self, parent):
        super().__init__()

        fmt = logging.Formatter('%(asctime)s|file:%(filename)s|line:%(lineno)d|%(message)s')
        self.setFormatter(fmt)
        self.plainTextEdit_log = parent.plainTextEdit_log
        self.setLevel(logging.DEBUG)
        self.logEmittedConn = LogEmittedConn()

    def emit(self, record):
        # 重写handler的emit事件，触发Signal -&gt; connected to TextEdit.append
        msg = self.format(record)
        self.logEmittedConn.signal.emit(msg)
</code></pre><p>这里面每次几emit(record)时，就emit到了Signal中，然后将Signal和控件互动起来,</p><pre><code>guih = GuiLoggerHandler(parent=self.ui)
#信号触发
guih.logEmittedConn.signal.connect(self.onLogEmitted)

# ui互动
@Slot()
def onLogEmitted(self, text):
    self.ui.plainTextEdit_log.appendPlainText(text)
    from PySide2.QtGui import QTextCursor
    self.ui.plainTextEdit_log.moveCursor(QTextCursor.End)
</code></pre><p>最终就实现了一个打印日志的界面窗口</p><p><img src=https://52etf.oss-cn-beijing.aliyuncs.com/picgo20200603223539.png alt=20200603223539></p><h2 id=尾声>尾声</h2><p>理解了Logger工作机制，运用QThread和Signal就可以轻松的实现界面动态显示Log的需求。</p></p></div></article><article id=article_tags><a class=item__tag href=/tags/pyqt>#PyQt</a>
<a class=item__tag href=/tags/pyside2>#PySide2</a>
<a class=item__tag href=/tags/logging>#logging</a></article><div style=text-align:center><img src=/img/weixin.jpg width=110px;><p>扫码关注：<strong>结丹记事本儿</strong>，更新有提醒</p></div><article id=article_nav><a href=http://52etf.net/blog/2020-06-04-%E5%95%86%E4%B8%9A%E7%BD%91%E7%AB%99%E7%9A%84%E6%8A%80%E6%9C%AF%E5%B0%8F%E7%BB%93/>新一篇：一个商业站点的技术总结</a>
<a href=http://52etf.net/blog/2020-06-03-%E6%8B%A6%E6%88%AAajax%E5%93%8D%E5%BA%94%E7%BB%93%E6%9E%9C/>老一篇：拦截Ajax响应结果</a> &nbsp;</article><article class=single><h3>推荐阅读:</h3><ul><li><a href=/blog/2020-06-02-pyqt%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%BA%94%E7%99%BB%E5%BD%95%E7%AA%97%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0-copy/>PyQt开发笔记（五）登录窗口</a></li><li><a href=/blog/2020-06-01-pyqt%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B8%89%E5%A4%9A%E7%BA%BF%E7%A8%8B/>PyQt开发笔记（三）多线程</a></li><li><a href=/blog/2020-06-01-pyqt%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E5%9B%9B%E9%80%9A%E7%94%A8worker/>PyQt开发笔记（四）通用的Worker</a></li><li><a href=/blog/2020-05-31-pyqt%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%BA%8C-/>PyQt开发笔记（二）</a></li><li><a href=/blog/2020-05-15-pyqt%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B8%80/>PyQt开发笔记（一）</a></li></ul></article><script src=//unpkg.com/valine/dist/Valine.min.js></script><div id=vcomments></div><script>new Valine({el:'#vcomments',appId:'oc9Q6EXPyOTsTB1u3TF69zx5-gzGzoHsz',appKey:'K9hd59av2lhDkYwXfBGAHFdB',placeholder:'请您在评论时遵守国家法律法规，谢谢',visitor:false,})</script></main><footer id=footer><ul><li><a href=http://52etf.net>版权&copy;52etf.net</a></li><li><a href=https://creativecommons.org/licenses/by-sa/4.0/deed.zh>协议CC BY-SA 4.0</a></li><li><a href=http://www.beian.miit.gov.cn>豫ICP备20016066号</a></li></ul></footer></body></html>