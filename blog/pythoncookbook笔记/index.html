<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><link id=favicon rel=icon type=image/x-icon href=/img/favicon.ico><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/github-markdown.min.css><link rel=stylesheet href=/css/addon.css><meta name=referrer content="no-referrer"><script src=https://unpkg.com/zooming/build/zooming.min.js></script><script>document.addEventListener('DOMContentLoaded',function(){new Zooming({scaleExtra:0.6,}).listen('.img-zoomable')})</script><title>我爱ETF</title></head><body><header id=header><nav class=topnav id=myTopNav><ol><li><a href=/>首页</a></li><li><a href=/dash/>市场仪表盘</a></li><li><a href=/books/>投资书单</a></li><li><a href=/funds/>精选基金</a></li><li><a href=/tools/>量化工具</a></li><li><a href=/tags/>词云</a></li><li><a href=/blog/>博客</a></li><li><a href=/about/>关于</a></li></ol></nav></header><main id=main><article id=markdown-body><h1>PythonCookbook笔记</h1><p>Jun 25, 2020</p><p>Python Cookbook是一本类参考书，非常适合作为案头参考。</p><p>不用很全面深入的掌握，但需要知道这些更pythonic的用法，合适的时候尝试去用，代码就会越来越好。</p><h2 id=数据结构和算法>数据结构和算法</h2><ol><li>*args, var = [1,2,3,4] 变长展开赋值</li><li>heapq.nlargest, nsmallest接收key作为排序对象</li><li>heqpq.heappush, heappop可以实现优先级压入栈和提取</li><li>collection.defaultdict(list),创建对应多值的k,v 对</li><li>d1.keys() - d2.keys(), -是集合操作，健集合支持-&|+等集合操作</li><li>用命名切片 s1 = slice(12,30), string1[s1]，让代码更具可读性</li><li>统计次数, collections.Counter, Counter.most_commont(3)</li><li>对字典排序，输入keys=lambda x: x[&lsquo;key&rsquo;]，其实可以简化为operator.itemgetter(&lsquo;key1&rsquo;, &lsquo;key2&rsquo; &mldr; )</li><li>对class类型排序，sorted(key=lambda u: &mldr;) 在lambda中定义排序的字段 或者 operator.attrgetter</li><li>itertools.groupby对dict进行分组</li><li>复杂的过滤时采用filter(func, values), func中定义true时保留的value</li><li>创建一个字典的子集，用到keys的集合操作 {key:prices[key] for key in prices.keys() & tech.keys() }</li><li>通过下标名称访问tuple和list，相比较于于class，更简洁, collections.namedtuple(&lsquo;Subscriber&rsquo;, [&lsquo;addr&rsquo;, &lsquo;joined&rsquo;])</li><li>合并两个字典, collections.ChainMap, 或者使用dict.update方法，还记得class.<strong>dict</strong>.update(attr)吗？</li></ol><h2 id=字符串>字符串</h2><ol><li>匹配文件名，可以用re.match，但更简便的是fnmatch.fnmatch, fnmatchcase</li><li>简单的匹配，&rsquo;&rsquo; in &lsquo;'&rsquo;, find(), replace, startwith, endwith (不建议切片)</li><li>re匹配换行符，可以用\n，推荐用re.DOTALL表示匹配任意字符包括换行</li><li>对字符串批量的替换，正确姿势是translate(map_dict),</li><li>对其字符串,ljust, rjust, center, format(:>10, :&lt;10>)等</li><li>用join来替代+连接符，+会创建对象并删除，开支很大</li><li>替换html tag，html.escape()</li><li>关于文本解析的关键字是PyParsing, Ply, BNF, EBNF，类似一个数据解析器，读取固定格式</li></ol><h2 id=数字和时间>数字和时间</h2><ol><li>浮点金融计算请用decimal模块</li><li>复数complex(2,4) or (2-4j), 运算用cmatch, sin/cos/exp</li><li>分数用fractions.Fraction</li><li>random.choice, sample(vlaues, N), .shuffle(values), randomint(start, end), radom()浮点数. random随机并不是真随机，因为有seed指示，可以用ssl.RAND_bytes()来获取</li><li>时间函数datetime, timedelta, pytz.TimeZone, astimezone</li></ol><h2 id=迭代和生成器>迭代和生成器</h2><ol><li>yield 和 iter用来创建函数和类的迭代，节约开支</li><li>反响迭代reversed()和__reversed__()</li><li>迭代器的切片，itertools.islice(c, startN, endN)</li><li>跳过一些行，文件操作中非常常用itertools.dropwhile(lambda line: line.startwith('#'), f)</li><li>chain，简单的sequence合并链接，开支很小，输出是一个迭代器</li><li>生成器是python的一个优良特性，原则上来说每个for循环的地方都可以优化generator</li><li>yieldfrom 递归生成器</li><li>heapq.merge(seq1, seq2) 递归合并的序列，开支非常小</li><li>迭代器替代while无限循环，非常pythonic的用法, for chunk in iter(lambda: f.read(10), b&rsquo;'), iter用一个callable和结尾，创建一个可结束的（退出机制）的迭代器</li></ol><h2 id=文件>文件</h2><ol><li>print(&lsquo;hi&rsquo;, file=f) 可以将输出重定向，更轻量级的logger</li><li>print(a, b, c, spe=&rsquo;,&rsquo;, end=&rsquo;\n&rsquo;)</li><li>open(fname, &lsquo;xt&rsquo;), x表示不存在时才创建文件，否则报错</li><li>固定长度读取迭代, iter(functools.patial(fp, SIZE))</li></ol><h2 id=编码>编码</h2><ol><li>import csv, 用NamedTuple来访问 NamedTuple(&lsquo;row&rsquo;, *headers), row = Row(*line) or csv.DictReader(fp)</li><li>bin2ascii.b2a_hex, a2b_hex, base64.encode, decode,</li><li>二进制数据的读取和写入暂时跳过，应用场景比较少，上次还是在解析爱立信设备的数据文件，可以自己开发解码文件</li><li>type元类的cls, metaclass, getattr, setattr 动态的和子类、instance互动</li></ol><h2 id=函数>函数</h2><ol><li>python3.x中加入了类型检查和函数注解，支持渐进式检查，可以用在基础的类型检查上，比如关键参数和输出。同时可以学习较复杂的类型检查。</li><li>partial(func, arg), 用来修正func的接受缺失的参数的个数</li><li>闭包和回调函数,用decoration解决更优雅</li></ol><h2 id=类>类</h2><ol start=4><li><strong>repr</strong>, <strong>str</strong> 方法</li><li><strong>enter</strong>, <strong>exit</strong> 让一个类支持with上下文语法</li><li><strong>slots</strong> = [&lsquo;year&rsquo;, &lsquo;month&rsquo;, &lsquo;day&rsquo;] 用来节约大量的开支，</li><li>__handler, <em>handler 首选后者，除非想进一步隐藏和禁止instance覆盖。 handler</em> 用来避免方法重叠</li><li>@property.getter, .setter, deleter, @property</li><li>super()表示父类的方法，通常初始化时会super().<strong>init</strong> 确保父类初始化成功</li><li>collections中有大量的抽象数据结构和操作集合</li><li>getattr(cls, &lsquo;name&rsquo;)(*args, **kwargs) ，也可以operator.methodcaller(&lsquo;name&rsquo;, *args)(cls)</li><li>points.sort(key=operator.methodcaller(&lsquo;distance&rsquo;, 0, 0)), 变相的实现了多次执行对象的方法</li><li>观察者模式: class基类实现通用的handler，来执行getattr；子类中定义getattr的具体实现，相当于对自身做了抽象，利用父类去提炼了共性handler。避免了判断handler name然后去执行，节省了if/else，从而直接去掉用，出错用raise捕捉</li><li>让类支持eq、gt、lt、or、ge，使用functools.total_ordering + 其中一个，便能简化</li><li></li></ol><h2 id=元编程>元编程</h2><ol><li>操控函数和类的源代码，使用装饰器、类装饰器、元类、签名对象、反射、exec</li><li>class handler, @classmethod, @staticmethod区别: 前者是实例的方法，第一个参数是self实例，中间是__new__/__init__之前的方法代表class本身，第一个参数必须指定为cls代表类自身，用作初始化前的类本身和环境参数的交互判断，或者逆向想要绕过__init__方法；由于发生在__init__前所以只能够调用其他的@classmethod（实例方法还未来得及实例化）；@staticmethod返回的永远是一个cls的函数（可以理解为class的私有函数，不会实例化，不会被重写，但可以改写为@classmethod). @classmethod增加实例化的判断，比如被基类、还是子类，可以调用子类的@classmethod。https://www.zhihu.com/question/20021164， <a href=https://zhuanlan.zhihu.com/p/28010894>https://zhuanlan.zhihu.com/p/28010894</a></li><li>functools.wraps 来保留decorator的元信息 def decor(func): @wraps(func) def wrapper(*args, **kwargs): return func(*args, *kwargs) return wrapper.</li><li>如果decorator接受参数输入，因为@decorator, func() = decorator(func) = decorator(x,y,z)(func), 故decorator(x,y,z) 必须是一个decorator，所以要在上例3的基础上外层再包装一个decorator， return 内层实际的decorator</li><li>带可选参数的decorator, 在函数章节的一个特性 decorator(func=None, *, arg1=xx, arg2=xx): if func=None return partial(decorator, arg1=xx, arg2=xx, arg3=xx)，对参数进行了截断处理，返回函数本身，然后再次运行一次。</li><li>@classmethod @normal_decorator @staticmethod的顺序有要求，meta method放置在外层，因为不能被实例化被调用，只能调用别人或者其他meta method</li><li>类的调用：实例化、<strong>new</strong>/@classmethod、@staticmethod，也就是除了第一种之外，还有两种访问。或者禁止第一种，强制要求第二三种访问。</li><li>捕捉类属性创建的顺序, <strong>prepare</strong> 在类被创建之前进行检查，__setitem__进行设置和报错</li><li>给元类添加可选参数，需要了解类创建的所有步骤，<strong>new</strong>, __init__初始化时强制类型参数 <strong>new</strong>(cls, name, bases, *, arg1=xx, arg2=xx) &mldr;</li><li>用函数生成函数，自定义函数名和handler，类似class工厂模式。对类进行再次抽象。types.new_class(cls_name, (bases), {&lsquo;metaclass&rsquo;: abc.ABCMeta, lambda ns: ns.update(cls_dict)})</li><li>看cookbook的样例能感觉到生产代码对逻辑的抽象层次非常的高，高到变量名字都失去了场景意义，而作为一个通用的组件。问题本身就是对场景的抽象。</li><li>from contextlib import contextmanager用来快速装饰一个含有yield的函数或者类，替代__entry__ , __exit__ 方法</li></ol><h2 id=模块和包>模块和包</h2><ol><li>module或者__init__中的__all__ 用来限定导入命名控件的集合，有些时候可以屏蔽掉不必要的变量</li><li>读取package中的一些数据 data = pkgutil.get_data(<strong>package</strong>, &lsquo;somedata.dat&rsquo;)</li><li>sys.path.extend，可以临时解决开发包不能被import的现象</li><li>通过字符串导入包, importlib.import_module(&lsquo;math&rsquo;) 类似动态创建类type.new_class(cls, name, bases, *, arg1=x&mldr;)</li><li>整体来看，理解了命名控件和__init__原理，就基本解决了99的导入问题</li></ol><h2 id=网络>网络</h2><ol><li>ipaddress处理一些关于IP地址的运算，可以用作开发小工具</li><li>hmac.new 来用签字一个hash和digest</li></ol><h2 id=并发>并发</h2><ol><li>原始的多线程创建，但要注意LOCK/q方法都不是线程安全的，没有互斥和琐机制，容易导入读写混乱。</li><li>最贱的写法是用Queen来共享一个对象读写，同时用with xx.lock() 来控制敏感共享数据读写</li><li>concurrent.PoolThreadExecutor用来创建一个pool.map(func, values)</li></ol><p>整体比较适合有经验的中级开发者，越往后越抽象，尤其是函数和类、元类、线程章节，属于高级内容。</p><p>值得一段时间练习后反复阅读。</p></article><article id=article_tags><a class=item__tag href=/tags/python>#Python</a>
<a class=item__tag href=/tags/%E7%AC%94%E8%AE%B0>#笔记</a></article><article id=article_nav><a href=http://52etf.net/blog/2020-06-03-pyqt%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B8%83%E4%B8%8D%E8%A7%84%E5%88%99%E6%8E%A7%E4%BB%B6/>新一篇：PyQt开发笔记（七）不规则进度条</a>
<a href=http://52etf.net/blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>老一篇：Python设计模式</a></article><article class=single><h3>推荐阅读:</h3><ol><li><a href=/blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>Python设计模式</a></li><li><a href=/blog/2020-06-10-%E4%B8%A4%E4%B8%AA%E6%9C%80%E5%A5%BD%E7%9A%84python%E5%9C%A8%E7%BA%BF%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/>两个最好的Python在线开发环境</a></li><li><a href=/blog/2020-03-27-python-import-tricks/>Note of Python import</a></li><li><a href=/blog/%E9%87%8D%E6%9E%84flask%E7%A8%8B%E5%BA%8F%E7%9B%AE%E5%BD%95/>重构Flask目录</a></li></ol></article><div style=text-align:center><img src=/img/weixin_banner.png width=40%;></div><script src=//unpkg.com/valine/dist/Valine.min.js></script><div id=vcomments></div><script>new Valine({el:'#vcomments',appId:'oc9Q6EXPyOTsTB1u3TF69zx5-gzGzoHsz',appKey:'K9hd59av2lhDkYwXfBGAHFdB',placeholder:'请您在评论时遵守国家法律法规，谢谢',visitor:false,})</script></main><footer id=footer><ul><li><a href=http://52etf.net>版权&copy;52etf.net</a></li><li><a href=https://creativecommons.org/licenses/by-sa/4.0/deed.zh>协议CC BY-SA 4.0</a></li><li><a href=http://www.beian.miit.gov.cn>豫ICP备20016066号</a></li></ul></footer></body></html>