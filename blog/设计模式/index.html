<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><link id=favicon rel=icon type=image/x-icon href=/img/favicon.ico><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/github-markdown.min.css><link rel=stylesheet href=/css/addon.css><meta name=referrer content="no-referrer"><script src=https://unpkg.com/zooming/build/zooming.min.js></script><script>document.addEventListener('DOMContentLoaded',function(){new Zooming({scaleExtra:0.6,}).listen('.img-zoomable')})</script><title>我爱ETF</title></head><body><header id=header><nav class=topnav id=myTopNav><ol><li><a href=/>首页</a></li><li><a href=/dash/>市场仪表盘</a></li><li><a href=/books/>投资书单</a></li><li><a href=/funds/>精选基金</a></li><li><a href=/tools/>量化工具</a></li><li><a href=/tags/>词云</a></li><li><a href=/blog/>博客</a></li><li><a href=/about/>关于</a></li></ol></nav></header><main id=main><article id=markdown-body><h1>Python设计模式</h1><p>Jun 25, 2020</p><p><img src=https://img9.doubanio.com/view/subject/s/public/s28890474.jpg alt></p><p>搜索首页图的时候，在豆瓣发现这本书风评很差，不过个人读完有些收货。整体来说，难度较小，适合初学者。</p><p>编程类的书都不适合买纸质的，大部分都是代码复制粘贴，真正的经验字句可能连四分之一都不到，读电子版比较好，看完练习下就差不多了。</p><p>在日后编程时，可以拿来做参考，快速的选定一两种设计模式，比较后便可以作为整体的设计框架。</p><h2 id=心得>心得</h2><p>程序通常可以分解为：设计模式、算法、语言实现。</p><p>设计模式跟语言无关，是面对一个问题的上层设计，通常跟事物对象的抽象模型有关，这些模型是计算机领域比较成熟的（或者新开发的），能够快速的表达对象的模型，例如工厂、建造、原型、适配、代理、装饰、状态等等。</p><p>开始编码前，不妨先思考下可以采用哪种模式比较合适。</p><p>设计模式跟现实世界的模式是相关的，有些是引申出来的，并不冲突，例如工厂模式，就是类的创建。是很自然的模式，你没有意识到这是一种模式，实际上已经用了很久。再比如修饰器，很好的Python特性，也是一种优秀的设计模式。</p><p>一个野路子的程序员和摸爬滚打专业程序员的区别在代码风格上。野路子通常是没有函数，一条路走到黑；稍好点的包几个func；高一级的用气了类。然而还是能直接感受到迎面而来的洗剪吹风格。</p><p>正规军的风格表现：</p><ol><li>长长的的Docstrng，并且在开始编码前已经设计完</li><li>动辄MVC，至少MC分离</li><li>用线程或者进程将阻塞和非阻塞分离</li><li>满屏堆积类</li><li>使用类的继承特性</li><li>使用类的meta元特性 <strong>setattr</strong>, <strong>getattr</strong>, <strong>str</strong></li><li>元特性释放Python的狂野，将继承类、instance互相串通，工厂和流水模式非常称心</li><li>大量使用expression、slice</li><li>大量使用装饰器</li><li>空格、缩进和命名统一符合PEP008</li><li>大量使用内部特性、函数和库: collection\set\dict\sorted\decoration等</li><li>强制使用类型检查，但不会过分深入（复杂度成倍增加）</li><li>大量使用__set__, __get__, __delete__</li><li></li></ol><h2 id=模式的分类>模式的分类</h2><ol><li>创建类型，也就是工厂模型，批量复制生产一些东西</li><li>结构类型，需要去配合完成一些事务的整体设计，比如MVC、装饰器、代理、外观模式、享元（鬼翻译）</li><li>行为模式，个体的行为模式，责任链、命令、解释器、观察者、状态、策略、模板</li></ol><h2 id=自然的模式>自然的模式</h2><p>有些模式是我们不经意间已经使用的，</p><h3 id=工厂模式>工厂模式</h3><p>使用标准类，但对象复杂时，用解析json/yaml/xml等文件的形式来初始化。</p><p>抽象工厂是工厂模式的泛化，将工厂类型（行为）抽象或者变量化。</p><h3 id=建造者模式>建造者模式</h3><p>无非是分解步骤，组装class的方法</p><h3 id=装饰器>装饰器</h3><p>在不改变主程序行为的情况下，对输入和输出进一步的处理。</p><p>相当于unix设计哲学中的PIPELINE概念</p><h3 id=mvc>MVC</h3><p>在flask和django中都有应用，典型的model、view、route分离。
日常编码也可以遵循这一原则，data, 表现, 控制逻辑分离
类等定义json、db数据组
类的方法和其他控制逻辑输出
输出用独立的模块来控制表现形式</p><h2 id=有些是非常值得有意去使用的>有些是非常值得有意去使用的，</h2><h3 id=复制模式>复制模式</h3><p>copy.deepcopy()</p><h3 id=适配器模式>适配器模式</h3><p>用Adapter类来封装其他类的同类属性。
但Adapter不会固定的编写其他类属性，而是传入参数的的方式</p><pre><code> Adapter(obj, dict(execute=其他类.method))
 self.obj = obj
 obj.__dict__.update(adapted_method)
</code></pre><h3 id=外观模式>外观模式</h3><p>总分结构中的总，称之为外观。
隐藏分支类的属性方法。</p><h3 id=享元翻译鬼才flayweight>享元（翻译鬼才）Flayweight</h3><p>主要解决大量对象的重复创建，类似工厂模式和元模式，创建了很多不必要的开销，可以对模型进一步的抽象，共性的部分只创建一个副本，只有特性变量和方法在获取共享元后调用方法，达到复用的目的。</p><pre><code>类的meta method __new__(cls, tree_type)
obj = cls.pool.get(tree_type, None)
if not None: 重新创建
直接返回
</code></pre><h3 id=代理模式>代理模式</h3><p>跟总分结构的外观模式很像，</p><h3 id=责任链模式>责任链模式</h3><p>是一种集体广播然后个体检查后自行执行的模式，听起来非常的自律，当然可以采用daemon监听消息。</p><p>这里说的是函数级别的责任链，根据方法名来自律执行。</p><pre><code>def handle(self, event):
    handler = 'handle_{}'.format(event)
    if hasattr(self, handler):
        method = getattr(self, handler)
        method(event)
    elif self.parent:
        self.parent.handle(event)
    elif hasattr(self, 'handle_default'):
        self.handle_default(event)
</code></pre><p>类和instance通过__getattr__, __setattr__被盘活，使用event来动态的构造和提取类来加载运行。</p><p>责任链可以用在函数、类级别的的广播场景。</p><h3 id=命令模式>命令模式</h3><p>不太容易理解，读起来感觉有些脱裤子放屁的意味（哪个模式不是呢）。跟前面的流水模式又很相似。</p><p>其本质是对“命令”（函数操作）进一步的包装，变成类以后，相当于初始化时并没有执行，只有execute时才真正执行。</p><p>这样做的好处，可以任意时间执行，可以灵活的组合命令，形成了类似pipeline的意思。</p><h3 id=解释器>解释器</h3><p>隐藏内部，用human语言和界面呈现，类似小爱和Alex声控</p><h3 id=观察者模式>观察者模式</h3><p>也称之为 订阅subscription 模式，工业设计中很常见，当一组数据发生改变，要通知到所有相关、外部订阅者。</p><ol><li>维持一个subscription列表</li><li>提供增加删除subscription的方法</li><li>通知到所有的subsription方法</li></ol><h3 id=状态机>状态机</h3><p>在Python中用state_machine来包装实现，工业设计中应该是非常常见，比如协议处理stack，diameter协议的状态。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#a6e22e>@act_as_state_machine</span>
<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Process</span>():
    <span style=color:#75715e>#声明状态</span>
    created <span style=color:#f92672>=</span> State(initial<span style=color:#f92672>=</span>True)
    waiting <span style=color:#f92672>=</span> State()
    runnig <span style=color:#f92672>=</span> State()
    terminated <span style=color:#f92672>=</span> State()
    blocked <span style=color:#f92672>=</span> State()
    swapped_out_waiting <span style=color:#f92672>=</span> State()
    swapped_out_blocked <span style=color:#f92672>=</span> State()

    <span style=color:#75715e>#转化的路径</span>
    wait <span style=color:#f92672>=</span> Event(from_states<span style=color:#f92672>=</span>(created, running, blocked,
    swapped_out_waiting), to_state<span style=color:#f92672>=</span>waiting)
    run <span style=color:#f92672>=</span> Event(from_states<span style=color:#f92672>=</span>waiting, to_state<span style=color:#f92672>=</span>running)
    terminate <span style=color:#f92672>=</span> Event(from_states<span style=color:#f92672>=</span>running, to_state<span style=color:#f92672>=</span>terminated)
    block <span style=color:#f92672>=</span> Event(from_states<span style=color:#f92672>=</span>(running, swapped_out_blocked),
    to_state<span style=color:#f92672>=</span>blocked)
    swap_wait <span style=color:#f92672>=</span> Event(from_states<span style=color:#f92672>=</span>waiting, to_state<span style=color:#f92672>=</span>swapped_out_waiting)
    swap_block <span style=color:#f92672>=</span> Event(from_states<span style=color:#f92672>=</span>blocked, to_state<span style=color:#f92672>=</span>swapped_out_blocked)

    <span style=color:#75715e>#定义状态转换前后的行为，需要做哪些事情，比如处理完buffer等</span>
    <span style=color:#a6e22e>@after</span>(<span style=color:#e6db74>&#39;wait&#39;</span>)
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>wait_info</span>(self):
        <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#39;{} entered waiting mode&#39;</span><span style=color:#f92672>.</span>format(self<span style=color:#f92672>.</span>name))
    <span style=color:#a6e22e>@after</span>(<span style=color:#e6db74>&#39;run&#39;</span>)
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>run_info</span>(self):
        <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#39;{} is running&#39;</span><span style=color:#f92672>.</span>format(self<span style=color:#f92672>.</span>name))
    <span style=color:#a6e22e>@before</span>(<span style=color:#e6db74>&#39;terminate&#39;</span>)
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>terminate_info</span>(self):
        <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#39;{} terminated&#39;</span><span style=color:#f92672>.</span>format(self<span style=color:#f92672>.</span>name))
    <span style=color:#a6e22e>@after</span>(<span style=color:#e6db74>&#39;block&#39;</span>)
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>block_info</span>(self):
        <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#39;{} is blocked&#39;</span><span style=color:#f92672>.</span>format(self<span style=color:#f92672>.</span>name))
    <span style=color:#a6e22e>@after</span>(<span style=color:#e6db74>&#39;swap_wait&#39;</span>)
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>swap_wait_info</span>(self):
        <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#39;{} is swapped out and waiting&#39;</span><span style=color:#f92672>.</span>format(self<span style=color:#f92672>.</span>name))
    <span style=color:#a6e22e>@after</span>(<span style=color:#e6db74>&#39;swap_block&#39;</span>)
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>swap_block_info</span>(self):
        <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#39;{} is swapped out and blocked&#39;</span><span style=color:#f92672>.</span>format(self<span style=color:#f92672>.</span>name))

    <span style=color:#75715e>#转换函数</span>
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>transition</span>(process, event, event_name):
    <span style=color:#66d9ef>try</span>:
        event()
    <span style=color:#66d9ef>except</span> InvalidStateTransition <span style=color:#66d9ef>as</span> err:
        <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#39;Error: transition of {} from {} to {} failed&#39;</span><span style=color:#f92672>.</span>format(process<span style=color:#f92672>.</span>name,
        process<span style=color:#f92672>.</span>current_state, event_name))

    <span style=color:#75715e>#当前的状态</span>
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>state_info</span>(process):
        <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#39;state of {}: {}&#39;</span><span style=color:#f92672>.</span>format(process<span style=color:#f92672>.</span>name, process<span style=color:#f92672>.</span>current_state))
</code></pre></div><h3 id=策略模式>策略模式</h3><p>太过宽泛，其实当你接收输入和参数判断时，就是一种策略。</p><p>设计模式的策略模式，指的是对输入能够自动判断，或者使用attrgettr, <strong>getattr</strong>, __get__等责任模式运行</p><h3 id=模板模式>模板模式</h3><p>类和函数的抽象，共享代码，包装差异的部分。</p><h2 id=一些编程行为>一些编程行为</h2><ol><li>@property,使class的method变为foo.property，而不是foo()的形式被调用</li><li>obj.<strong>dict</strong>.update(attr),用来（复制对象后，）动态更新类的方法和属性</li><li>@abstractmethod 用来设计一些抽象化的类，不能被实例化不能别继承。其强制方法也要重写。但重写后的抽象类可以被继承。抽象类相当于原子类。</li><li>@data.setter属性，可以将方法转为 foo.data = bar 的形式来替代函数调用</li></ol><h3 id=小结>小结</h3><p>总的来说，设计模式是为了简化规模程序的开销，降低复杂度，增加复用度。</p><p>不管是写小的工具还是大型程序，都可以养成设计模式的习惯。</p></article><article id=article_tags><a class=item__tag href=/tags/python>#Python</a>
<a class=item__tag href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F>#设计模式</a>
<a class=item__tag href=/tags/%E7%AC%94%E8%AE%B0>#笔记</a></article><article id=article_nav><a href=http://52etf.net/blog/pythoncookbook%E7%AC%94%E8%AE%B0/>新一篇：PythonCookbook笔记</a>
<a href=http://52etf.net/blog/cat/>老一篇：吸猫</a></article><article class=single><h3>推荐阅读:</h3><ol><li><a href=/blog/2020-06-10-%E4%B8%A4%E4%B8%AA%E6%9C%80%E5%A5%BD%E7%9A%84python%E5%9C%A8%E7%BA%BF%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/>两个最好的Python在线开发环境</a></li><li><a href=/blog/2020-03-27-python-import-tricks/>Note of Python import</a></li><li><a href=/blog/%E9%87%8D%E6%9E%84flask%E7%A8%8B%E5%BA%8F%E7%9B%AE%E5%BD%95/>重构Flask目录</a></li></ol></article><div style=text-align:center><img src=/img/weixin_banner.png width=40%;></div><script src=//unpkg.com/valine/dist/Valine.min.js></script><div id=vcomments></div><script>new Valine({el:'#vcomments',appId:'oc9Q6EXPyOTsTB1u3TF69zx5-gzGzoHsz',appKey:'K9hd59av2lhDkYwXfBGAHFdB',placeholder:'请您在评论时遵守国家法律法规，谢谢',visitor:false,})</script></main><footer id=footer><ul><li><a href=http://52etf.net>版权&copy;52etf.net</a></li><li><a href=https://creativecommons.org/licenses/by-sa/4.0/deed.zh>协议CC BY-SA 4.0</a></li><li><a href=http://www.beian.miit.gov.cn>豫ICP备20016066号</a></li></ul></footer></body></html>