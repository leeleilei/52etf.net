<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>PySide2 on 我爱ETF</title><link>http://52etf.net/tags/pyside2/</link><description>Recent content in PySide2 on 我爱ETF</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 26 Jun 2020 00:00:00 +0000</lastBuildDate><atom:link href="http://52etf.net/tags/pyside2/index.xml" rel="self" type="application/rss+xml"/><item><title>PyQt开发笔记（七）不规则进度条</title><link>http://52etf.net/blog/2020-06-03-pyqt%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B8%83%E4%B8%8D%E8%A7%84%E5%88%99%E6%8E%A7%E4%BB%B6/</link><pubDate>Fri, 26 Jun 2020 00:00:00 +0000</pubDate><guid>http://52etf.net/blog/2020-06-03-pyqt%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B8%83%E4%B8%8D%E8%A7%84%E5%88%99%E6%8E%A7%E4%BB%B6/</guid><description>和打印日志一样，进度条通常是为了稍微管理下用户等待预期，同时直白的告诉他们我还没死，等会儿再C+A+D杀死我。 我们理解了信号和UI交互的逻辑，可以很容易理解进度条的实现逻辑， 一个label用来显示进度</description></item><item><title>PyQt开发笔记（六）日志打印窗口</title><link>http://52etf.net/blog/2020-06-03-pyqt%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E5%85%AD%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0%E7%AA%97%E5%8F%A3/</link><pubDate>Wed, 03 Jun 2020 00:00:00 +0000</pubDate><guid>http://52etf.net/blog/2020-06-03-pyqt%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E5%85%AD%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0%E7%AA%97%E5%8F%A3/</guid><description>通常习惯是用Python logging模块打印到日志文件中，但在GUI程序中，如果能实施调整日志等级，并打印到一个Text空间上，功能将会非常精彩。 很显然，要用到前几章谈到的QThread，Signa</description></item><item><title>PyQt开发笔记（五）登录窗口</title><link>http://52etf.net/blog/2020-06-02-pyqt%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%BA%94%E7%99%BB%E5%BD%95%E7%AA%97%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0-copy/</link><pubDate>Tue, 02 Jun 2020 00:00:00 +0000</pubDate><guid>http://52etf.net/blog/2020-06-02-pyqt%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%BA%94%E7%99%BB%E5%BD%95%E7%AA%97%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0-copy/</guid><description>如何开发一个类似微信和QQ的登录提示框，用于验证或者预制输入（例如选择语言、代理服务器等）。 我们只看简单的逻辑实现，至于修饰图片、大小和布局不再本文讨论范围。 控制窗口的创建和显示 我们知道最简单的窗口是</description></item><item><title>PyQt开发笔记（三）多线程</title><link>http://52etf.net/blog/2020-06-01-pyqt%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B8%89%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link><pubDate>Mon, 01 Jun 2020 00:00:00 +0000</pubDate><guid>http://52etf.net/blog/2020-06-01-pyqt%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B8%89%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid><description>主进程 每一个Qt程序被创建时，默认有一个主线程，启动无限循环，并监控Signal。 我们看到的打开窗口 、点按钮、关闭窗口就是主线程的功劳。 from PySide2.QtWidgets import QApplication, QMainWindow app = QApplication(sys.argv) #主线程Application window = MainWindow() # 窗口 window.show() sys.exit(app.exec_()) 但</description></item><item><title>PyQt开发笔记（四）通用的Worker</title><link>http://52etf.net/blog/2020-06-01-pyqt%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E5%9B%9B%E9%80%9A%E7%94%A8worker/</link><pubDate>Mon, 01 Jun 2020 00:00:00 +0000</pubDate><guid>http://52etf.net/blog/2020-06-01-pyqt%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E5%9B%9B%E9%80%9A%E7%94%A8worker/</guid><description>线程通信 概念很大，但比较容易理解。 GUI程序的核心在于交互，界面上的元素互动交互，例如鼠标移动，打飞机游戏跟着滚动，其他物品躲避。 其次是用户和界面直接的交互，比如输入一些信息、点击按钮。 这些交互被封装</description></item><item><title>PyQt开发笔记（二）</title><link>http://52etf.net/blog/2020-05-31-pyqt%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%BA%8C-/</link><pubDate>Sun, 31 May 2020 00:00:00 +0000</pubDate><guid>http://52etf.net/blog/2020-05-31-pyqt%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%BA%8C-/</guid><description>(转载请注明：公众号-&amp;gt;结丹记事本儿) 用PySide2还是PyQt5 从功能上两者相似度是99.9%，由于版权的历史原因，在技术转让中最终达成的协议是，出了两个版本号，对应三个使用协议。 PySid</description></item><item><title>PyQt开发笔记（一）</title><link>http://52etf.net/blog/2020-05-15-pyqt%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B8%80/</link><pubDate>Fri, 15 May 2020 00:00:00 +0000</pubDate><guid>http://52etf.net/blog/2020-05-15-pyqt%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B8%80/</guid><description>License 观摩过wxWidget和GTK后尝试试用GTK，单单一个开发环境耗费了一天的时间没搞定，转而回 顾曾经放弃的PyQt。起初是记得它的License是商业License，需要购买，如今细看完全不是 那么回</description></item></channel></rss>